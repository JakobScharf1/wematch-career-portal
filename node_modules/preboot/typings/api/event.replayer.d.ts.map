{"version":3,"file":"event.replayer.d.ts","sources":["event.replayer.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NodeContext, PrebootAppData, PrebootData, PrebootEvent, PrebootWindow } from '../common/preboot.interfaces';\nexport declare function _window(): PrebootWindow;\nexport declare class EventReplayer {\n    clientNodeCache: {\n        [key: string]: Element;\n    };\n    replayStarted: boolean;\n    win: PrebootWindow;\n    /**\n     * Window setting and getter to facilitate testing of window\n     * in non-browser environments\n     */\n    setWindow(win: PrebootWindow): void;\n    /**\n     * Window setting and getter to facilitate testing of window\n     * in non-browser environments\n     */\n    getWindow(): PrebootWindow;\n    /**\n     * Replay all events for all apps. this can only be run once.\n     * if called multiple times, will only do something once\n     */\n    replayAll(): void;\n    /**\n     * Replay all events for one app (most of the time there is just one app)\n     * @param appData\n     */\n    replayForApp(appData: PrebootAppData): void;\n    /**\n     * Replay one particular event\n     * @param appData\n     * @param prebootEvent\n     */\n    replayEvent(appData: PrebootAppData, prebootEvent: PrebootEvent): void;\n    /**\n     * Switch the buffer for one particular app (i.e. display the client\n     * view and destroy the server view)\n     * @param appData\n     */\n    switchBuffer(appData: PrebootAppData): void;\n    /**\n     * Finally, set focus, remove all the event listeners and remove\n     * any freeze screen that may be there\n     * @param prebootData\n     */\n    cleanup(prebootData: PrebootData): void;\n    setFocus(activeNode: NodeContext): void;\n    /**\n     * Given a node from the server rendered view, find the equivalent\n     * node in the client rendered view. We do this by the following approach:\n     *      1. take the name of the server node tag (ex. div or h1 or input)\n     *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)\n     *      3. use that value as a selector to get all the matching client nodes\n     *      4. loop through all client nodes found and for each generate a key value\n     *      5. compare the client key to the server key; once there is a match,\n     *          we have our client node\n     *\n     * NOTE: this only works when the client view is almost exactly the same as\n     * the server view. we will need an improvement here in the future to account\n     * for situations where the client view is different in structure from the\n     * server view\n     */\n    findClientNode(serverNodeContext: NodeContext): HTMLElement | null;\n}\n"]}